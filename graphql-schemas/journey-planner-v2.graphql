# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: QueryType
}

"This directive allows results to be deferred during execution"
directive @defer on FIELD

"Interface for places, i.e. quays, stop places, parks"
interface PlaceInterface {
    id: ID!
    latitude: Float
    longitude: Float
}

"Authority involved in public transportation. An organisation under which the responsibility of organising the transport service in a certain area is placed."
type Authority {
    fareUrl: String
    "Authority id"
    id: ID!
    lang: String
    lines: [Line]!
    name: String!
    phone: String
    "Get all situations active for the authority"
    situations: [PtSituationElement]!
    timezone: String!
    url: String
}

type BikePark implements PlaceInterface {
    id: ID!
    latitude: Float
    longitude: Float
    name: String!
    realtime: Boolean
    spacesAvailable: Int
}

type BikeRentalStation implements PlaceInterface {
    allowDropoff: Boolean
    bikesAvailable: Int
    description: String
    id: ID!
    latitude: Float
    longitude: Float
    name: String!
    networks: [String]!
    realtimeOccupancyAvailable: Boolean
    spacesAvailable: Int
}

type BookingArrangement {
    "When should service be booked?"
    bookWhen: PurchaseWhen
    "Who has access to book service?"
    bookingAccess: BookingAccess
    "Who should ticket be contacted for booking"
    bookingContact: Contact
    "How should service be booked?"
    bookingMethods: [BookingMethod]
    "Textual description of booking arrangement for service"
    bookingNote: String
    "When should ticket be purchased?"
    buyWhen: [PurchaseMoment]
    "Latest time service can be booked. ISO 8601 timestamp"
    latestBookingTime: LocalTime
    "Minimum period in advance service can be booked as a ISO 8601 duration"
    minimumBookingPeriod: String
}

type Branding {
    "Description of branding."
    description: String
    id: String
    "URL to an image be used for branding"
    image: String
    "Full name to be used for branding."
    name: String
    "URL to be used for branding"
    url: String
}

type CarPark implements PlaceInterface {
    capacity: Int
    capacityHandicap: Int
    capacityRecharging: Int
    id: ID!
    latitude: Float
    longitude: Float
    name: String!
    realtimeOccupancyAvailable: Boolean
    spacesAvailable: Int
    spacesAvailableHandicap: Int
    spacesAvailableRecharging: Int
}

type Contact {
    "Name of person to contact"
    contactPerson: String
    "Email adress for contact"
    email: String
    "Textual description of how to get in contact"
    furtherDetails: String
    "Phone number for contact"
    phone: String
    "Url for contact"
    url: String
}

"A planned vehicle journey with passengers on a given date."
type DatedServiceJourney {
    id: ID!
    "Return the operating/service day the ServiceJourney run on."
    operatingDay: Date!
    "The DatedServiceJourney replaced by this DSJ. This is based on planed alterations, not real-time cancelations."
    replacementFor: DatedServiceJourney
    "Whether journey is as planned, a cancellation, an extra journey or replaced."
    serviceAlteration: ServiceAlteration
    serviceJourney: ServiceJourney!
    "Get all situations active for the DatedServiceJourney"
    situations: [PtSituationElement]!
}

"An advertised destination of a specific journey pattern, usually displayed on a head sign or at other on-board locations."
type DestinationDisplay {
    "Name of destination to show on front of vehicle."
    frontText: String
}

"List of visits to quays as part of vehicle journeys. Updated with real time information where available"
type EstimatedCall {
    "Actual time of arrival at quay. Updated from real time information if available"
    actualArrivalTime: DateTime
    "Actual time of departure from quay. Updated with real time information if available"
    actualDepartureTime: DateTime
    "Scheduled time of arrival at quay. Not affected by read time updated"
    aimedArrival: TimeAndDayOffset @deprecated(reason: "Use aimedArrivalTime")
    "Scheduled time of arrival at quay. Not affected by read time updated"
    aimedArrivalTime: DateTime
    "Scheduled time of departure from quay. Not affected by read time updated"
    aimedDeparture: TimeAndDayOffset @deprecated(reason: "Use aimedDepartureTime")
    "Scheduled time of departure from quay. Not affected by read time updated"
    aimedDepartureTime: DateTime
    "Booking arrangements for flexible service."
    bookingArrangements: BookingArrangement
    "Whether stop is cancellation."
    cancellation: Boolean
    "The date the estimated call is valid for."
    date: Date
    destinationDisplay: DestinationDisplay
    "Expected time of arrival at quay. Updated with real time information if available"
    expectedArrival: TimeAndDayOffset @deprecated(reason: "Use expectedArrivalTime")
    "Expected time of arrival at quay. Updated with real time information if available."
    expectedArrivalTime: DateTime
    "Expected time of departure from quay. Updated with real time information if available"
    expectedDeparture: TimeAndDayOffset @deprecated(reason: "Use expectedDepartureTime")
    "Expected time of departure from quay. Updated with real time information if available."
    expectedDepartureTime: DateTime
    "Whether this call is part of a flexible trip. This means that arrival or departure times are not scheduled but estimated within specified operating hours."
    flexible: Boolean
    "Whether vehicle may be alighted at quay."
    forAlighting: Boolean
    "Whether vehicle may be boarded at quay."
    forBoarding: Boolean
    "Server name - for debugging only!"
    hostname: String @deprecated(reason: "For debugging only")
    notices: [Notice]!
    "OccupancyStatus."
    occupancyStatus: Occupancy @deprecated(reason: "Not yet officially supported.")
    "Whether the updated estimates are expected to be inaccurate."
    predictionInaccurate: Boolean
    quay: Quay
    "Whether this call has been updated with real time information."
    realtime: Boolean
    realtimeState: RealtimeState
    "Whether vehicle will only stop on request."
    requestStop: Boolean
    serviceJourney: ServiceJourney
    "Get all relevant situations for this EstimatedCall."
    situations: [PtSituationElement]!
    "Whether this is a timing point or not. Boarding and alighting is not allowed at timing points."
    timingPoint: Boolean
}

type Interchange {
    FromLine: Line
    FromServiceJourney: ServiceJourney
    ToLine: Line
    ToServiceJourney: ServiceJourney
    "The interchange is guaranteed by the operator(s). Usually up to a maximum wait time."
    guaranteed: Boolean
    "The Line/Route/ServiceJourney changes, but the passenger can stay seated."
    staySeated: Boolean
}

type JourneyPattern {
    destinationDisplay: DestinationDisplay @deprecated(reason: "Get destinationDisplay from estimatedCall or timetabledPassingTime instead. DestinationDisplay from JourneyPattern is not correct according to model, will give misleading results in some cases and will be removed! (This is because a DestinationDisplay can change in the middle of a JourneyPattern.)")
    directionType: DirectionType
    id: ID!
    line: Line!
    name: String
    notices: [Notice]!
    pointsOnLink: PointsOnLink
    "Quays visited by service journeys for this journey patterns"
    quays: [Quay!]!
    serviceJourneys: [ServiceJourney!]!
    "List of service journeys for the journey pattern for a given date"
    serviceJourneysForDate(date: Date): [ServiceJourney!]!
    "Get all situations active for the journey pattern"
    situations: [PtSituationElement]!
}

type KeyValue {
    "Identifier of value."
    key: String
    "Identifier of type of key"
    typeOfKey: String
    "The actual value"
    value: String
}

"Part of a trip pattern. Either a ride on a public transport vehicle or access or path link to/from/between places"
type Leg {
    "The aimed date and time this leg ends."
    aimedEndTime: DateTime
    "The aimed date and time this leg starts."
    aimedStartTime: DateTime
    "For ride legs, the service authority used for this legs. For non-ride legs, null."
    authority: Authority
    bookingArrangements: BookingArrangement
    "For ride legs, the dated service journey if it exist in planned data. If not, null."
    datedServiceJourney: DatedServiceJourney
    "In the case of a flexible journey, this will represent the duration of the best-case scenario, where the vehicle drives directly to the destination for the current passenger."
    directDuration: Long
    "The distance traveled while traversing the leg in meters."
    distance: Float
    "The legs's duration in seconds"
    duration: Long
    "The date and time this leg ends."
    endTime: DateTime @deprecated(reason: "Replaced with expectedEndTime")
    "The expected, realtime adjusted date and time this leg ends."
    expectedEndTime: DateTime
    "The expected, realtime adjusted date and time this leg starts."
    expectedStartTime: DateTime
    "EstimatedCall for the quay where the leg originates."
    fromEstimatedCall: EstimatedCall
    "The Place where the leg originates."
    fromPlace: Place!
    interchangeFrom: Interchange
    interchangeTo: Interchange
    "For ride legs, estimated calls for quays between the Place where the leg originates and the Place where the leg ends. For non-ride legs, empty list."
    intermediateEstimatedCalls: [EstimatedCall]!
    "For ride legs, intermediate quays between the Place where the leg originates and the Place where the leg ends. For non-ride legs, empty list."
    intermediateQuays: [Quay]!
    "For ride legs, the line. For non-ride legs, null."
    line: Line
    "The mode of transport or access (e.g., foot) used when traversing this leg."
    mode: Mode
    "For ride legs, the operator used for this legs. For non-ride legs, null."
    operator: Operator
    "For ride legs, the transit organisation that operates the service used for this legs. For non-ride legs, null."
    organisation: Organisation @deprecated(reason: "Use 'authority' instead.")
    "The legs's geometry."
    pointsOnLink: PointsOnLink
    "Whether there is real-time data about this leg"
    realTime: Boolean @deprecated(reason: "Should not be camelCase. Use realtime instead.")
    "Whether there is real-time data about this leg"
    realtime: Boolean
    "Whether this leg is with a rented bike."
    rentedBike: Boolean
    "Whether this leg is a ride leg or not."
    ride: Boolean
    "For ride legs, the service journey. For non-ride legs, null."
    serviceJourney: ServiceJourney
    "For ride legs, all estimated calls for the service journey. For non-ride legs, empty list."
    serviceJourneyEstimatedCalls: [EstimatedCall]!
    "All relevant situations for this leg"
    situations: [PtSituationElement]!
    "The date and time this leg begins."
    startTime: DateTime @deprecated(reason: "Replaced with expectedStartTime")
    "Do we continue from a specified via place"
    steps: [PathGuidance]!
    "EstimatedCall for the quay where the leg ends."
    toEstimatedCall: EstimatedCall
    "The Place where the leg ends."
    toPlace: Place!
    "The transport sub mode (e.g., localBus or expressBus) used when traversing this leg. Null if leg is not a ride"
    transportSubmode: TransportSubmode
    "Do we continue from a specified via place"
    via: Boolean
}

"A group of routes which is generally known to the public by a similar name or number"
type Line {
    authority: Authority
    bikesAllowed: BikesAllowed
    "Booking arrangements for flexible line."
    bookingArrangements: BookingArrangement
    description: String
    "Type of flexible line, or null if line is not flexible."
    flexibleLineType: FlexibleLineType
    id: ID!
    journeyPatterns: [JourneyPattern]
    "List of keyValue pairs for the line."
    keyValues: [KeyValue]
    name: String
    notices: [Notice]!
    operator: Operator
    organisation: Organisation @deprecated(reason: "Use 'authority' instead.")
    presentation: Presentation
    "Publicly announced code for line, differentiating it from other lines for the same operator."
    publicCode: String
    quays: [Quay]!
    serviceJourneys: [ServiceJourney]!
    "Get all situations active for the line"
    situations: [PtSituationElement]!
    transportMode: TransportMode
    transportSubmode: TransportSubmode
    url: String
}

"Text with language"
type MultilingualString {
    language: String
    value: String
}

type Notice {
    id: String
    publicCode: String
    text: String
}

"Organisation providing public transport services."
type Operator {
    "Branding for operator."
    branding: Branding
    "Operator id"
    id: ID!
    lines: [Line]!
    name: String!
    phone: String
    serviceJourney: [ServiceJourney]!
    url: String
}

"Deprecated! Replaced by authority and operator."
type Organisation {
    fareUrl: String
    "Organisation id"
    id: ID!
    lang: String
    lines: [Line]!
    name: String!
    phone: String
    "Get all situations active for the organisation"
    situations: [PtSituationElement]!
    timezone: String!
    url: String
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

"A series of turn by turn instructions used for walking, biking and driving."
type PathGuidance {
    "This step is on an open area, such as a plaza or train platform, and thus the directions should say something like \"cross\""
    area: Boolean
    "The name of this street was generated by the system, so we should only display it once, and generally just display right/left directions"
    bogusName: Boolean
    "The distance in meters that this step takes."
    distance: Float
    "When exiting a highway or traffic circle, the exit name/number."
    exit: String
    "The absolute direction of this step."
    heading: AbsoluteDirection
    "The latitude of the step."
    latitude: Float
    "Direction information as readable text."
    legStepText(locale: Locale = no): String
    "The longitude of the step."
    longitude: Float
    "The relative direction of this step."
    relativeDirection: RelativeDirection
    "Indicates whether or not a street changes direction at an intersection."
    stayOn: Boolean
    "The name of the street."
    streetName: String
}

"Common super class for all places (stop places, quays, car parks, bike parks and bike rental stations )"
type Place {
    "The bike parking related to the place"
    bikePark: BikePark
    "The bike rental station related to the place"
    bikeRentalStation: BikeRentalStation
    "The car parking related to the place"
    carPark: CarPark
    "The latitude of the place."
    latitude: Float!
    "The longitude of the place."
    longitude: Float!
    "For transit quays, the name of the quay. For points of interest, the name of the POI."
    name: String
    "The quay related to the place."
    quay: Quay
    "Type of vertex. (Normal, Bike sharing station, Bike P+R, Transit quay) Mostly used for better localization of bike sharing and P+R station names"
    vertexType: VertexType
}

type PlaceAtDistance {
    distance: Int
    id: ID! @deprecated(reason: "Id is not referable or meaningful and will be removed")
    place: PlaceInterface
}

"A list of coordinates encoded as a polyline string (see http://code.google.com/apis/maps/documentation/polylinealgorithm.html)"
type PointsOnLink {
    "The number of points in the string"
    length: Int
    "The encoded points of the polyline. Be aware that the string could contain escape characters that need to be accounted for. (https://www.freeformatter.com/javascript-escape.html)"
    points: String
}

"Types describing common presentation properties"
type Presentation {
    colour: String
    textColour: String
}

"Simple public transport situation element"
type PtSituationElement {
    "Advice of situation in all different translations available"
    advice: [MultilingualString!]!
    "Get affected authority for this situation element"
    authority: Authority
    datedServiceJourneys: [DatedServiceJourney]!
    "Description of situation in all different translations available"
    description: [MultilingualString!]!
    "Details of situation in all different translations available"
    detail: [MultilingualString!]! @deprecated(reason: "Not allowed according to profile. Use ´advice´ instead.")
    id: ID!
    "Url with more information"
    infoLink: String @deprecated(reason: "Use the attribute infoLinks instead.")
    "Optional links to more information."
    infoLinks: [infoLink]
    "Get all journey patterns for this situation element"
    journeyPatterns: [JourneyPattern]!
    lines: [Line]!
    organisation: Organisation @deprecated(reason: "Use 'authority' instead.")
    "Priority-level of this situation, 1 is highest priority, 0 means unknown."
    priority: Int
    quays: [Quay]!
    "Authority that reported this situation"
    reportAuthority: Authority @deprecated(reason: "Not yet officially supported. May be removed or renamed.")
    "ReportType of this situation"
    reportType: ReportType
    serviceJourneys: [ServiceJourney]!
    "Severity of this situation "
    severity: Severity
    "Operator's internal id for this situation"
    situationNumber: String
    "StopConditions of this situation"
    stopConditions: [StopCondition]! @deprecated(reason: "Temporary attribute used for data-verification.")
    stopPlaces: [StopPlace]!
    "Summary of situation in all different translations available"
    summary: [MultilingualString!]!
    "Period this situation is in effect"
    validityPeriod: ValidityPeriod
}

"A place such as platform, stance, or quayside where passengers have access to PT vehicles."
type Quay implements PlaceInterface {
    description: String
    "List of visits to this quay as part of vehicle journeys."
    estimatedCalls(
        "Indicates that realtime-cancelled trips should also be included."
        includeCancelledTrips: Boolean = false,
        "Limit the total number of departures returned."
        numberOfDepartures: Int = 5,
        "Limit the number of departures per line and destination display returned. The parameter is only applied when the value is between 1 and 'numberOfDepartures'."
        numberOfDeparturesPerLineAndDestinationDisplay: Int,
        omitNonBoarding: Boolean = false,
        "DateTime for when to fetch estimated calls from. Default value is current time"
        startTime: DateTime,
        timeRange: Int = 86400,
        "Parameters for indicating the only authorities and/or lines or quays to list estimatedCalls for"
        whiteListed: InputWhiteListed,
        "Only show estimated calls for selected modes."
        whiteListedModes: [Mode]
    ): [EstimatedCall]!
    "Geometry for flexible area."
    flexibleArea: Coordinates
    id: ID!
    "List of journey patterns servicing this quay"
    journeyPatterns: [JourneyPattern]!
    latitude: Float
    "List of lines servicing this quay"
    lines: [Line!]!
    longitude: Float
    name: String!
    "Public code used to identify this quay within the stop place. For instance a platform code."
    publicCode: String
    "Get all situations active for the quay"
    situations: [PtSituationElement]!
    "The stop place to which this quay belongs to."
    stopPlace: StopPlace
    stopType: StopType
    timezone: String!
    "Whether this quay is suitable for wheelchair boarding."
    wheelchairAccessible: WheelchairBoarding
}

type QuayAtDistance {
    distance: Int
    id: ID!
    quay: Quay
}

type QueryType {
    "Get all authorities"
    authorities: [Authority]!
    "Get an authority by ID"
    authority(id: String!): Authority
    "Get a single bike park based on its id"
    bikePark(id: String!): BikePark
    "Get all bike parks"
    bikeParks: [BikePark]!
    "Get a single bike rental station based on its id"
    bikeRentalStation(id: String!): BikeRentalStation
    "Get all bike rental stations"
    bikeRentalStations(ids: [String]): [BikeRentalStation]!
    "Get all bike rental stations within the specified bounding box."
    bikeRentalStationsByBbox(maximumLatitude: Float, maximumLongitude: Float, minimumLatitude: Float, minimumLongitude: Float): [BikeRentalStation]!
    "Get a single car park based on its id"
    carPark(id: String!): CarPark
    "Get all car parks"
    carParks(ids: [String]): [CarPark]!
    "Get a single dated service journey based on its id"
    datedServiceJourney(id: String!): DatedServiceJourney
    "List dated service journeys"
    datedServiceJourneys(
        "Set of serviceAlteration to fetch entities for."
        alterations: [ServiceAlteration],
        "Set of authorities ids to fetch serviceJourneys for."
        authorities: [String],
        "Set of line ids to fetch entities for."
        lines: [String],
        "Set of dates to fetch entites for."
        operatingDays: [Date],
        "Set of serviceJourney ids to fetch entities for."
        serviceJourneys: [String]
    ): [DatedServiceJourney]!
    "Get a single line based on its id"
    line(id: String!): Line
    "Get all lines"
    lines(
        "Set of ids of authorities to fetch lines for."
        authorities: [String],
        flexibleLineTypes: [FlexibleLineType],
        ids: [String],
        name: String,
        publicCode: String,
        publicCodes: [String],
        transportModes: [TransportMode]
    ): [Line]!
    "Get all places (quays, stop places, car parks etc. with coordinates) within the specified radius from a location. The returned type has two fields place and distance. The search is done by walking so the distance is according to the network of walkables."
    nearest(
        "fetching only nodes after this node (exclusive)"
        after: String,
        "fetching only nodes before this node (exclusive)"
        before: String,
        "Only include places that match one of the given ids."
        filterByIds: InputFilters,
        "Only affects queries for quays and stop places. If true only quays and stop places with at least one visiting line are included."
        filterByInUse: Boolean = false,
        "Only include places that include this mode. Only checked for places with mode i.e. quays, departures."
        filterByModes: [Mode],
        "Only include places of given types if set. Default accepts all types"
        filterByPlaceTypes: [FilterPlaceType] = [quay, stopPlace, bicycleRent, bikePark, carPark],
        "fetching only the first certain number of nodes"
        first: Int,
        "fetching only the last certain number of nodes"
        last: Int,
        "Latitude of the location"
        latitude: Float!,
        "Longitude of the location"
        longitude: Float!,
        "Maximum distance (in meters) to search for from the specified location. Default is 2000m."
        maximumDistance: Int = 2000,
        "Maximum number of results. Search is stopped when this limit is reached. Default is 20."
        maximumResults: Int = 20,
        "MultiModalMode for query. To control whether multi modal parent stop places, their mono modal children or both are included in the response. Does not affect mono modal stop places that do not belong to a multi modal stop place. Only applicable for placeType StopPlace"
        multiModalMode: MultiModalMode = parent
    ): placeAtDistanceConnection
    "Get all notices"
    notices: [Notice]!
    "Get a operator by ID"
    operator(id: String!): Operator
    "Get all operators"
    operators: [Operator]!
    organisation(id: String!): Organisation @deprecated(reason: "Use 'authority' instead.")
    organisations: [Organisation]! @deprecated(reason: "Use 'authorities' instead.")
    "Get a single quay based on its id)"
    quay(id: String!): Quay
    "Get all quays"
    quays(ids: [String], name: String): [Quay]!
    "Get all quays within the specified bounding box"
    quaysByBbox(
        authority: String,
        "If true only quays with at least one visiting line are included."
        filterByInUse: Boolean = false,
        maximumLatitude: Float,
        maximumLongitude: Float,
        minimumLatitude: Float,
        minimumLongitude: Float
    ): [Quay]!
    "Get all quays within the specified radius from a location. The returned type has two fields quay and distance"
    quaysByRadius(
        "fetching only nodes after this node (exclusive)"
        after: String,
        authority: String,
        "fetching only nodes before this node (exclusive)"
        before: String,
        "fetching only the first certain number of nodes"
        first: Int,
        "fetching only the last certain number of nodes"
        last: Int,
        "Latitude of the location"
        latitude: Float!,
        "Longitude of the location"
        longitude: Float!,
        "Radius (in meters) to search for from the specified location"
        radius: Int!
    ): quayAtDistanceConnection
    "Get default routing parameters."
    routingParameters: RoutingParameters
    "Get a single service journey based on its id"
    serviceJourney(id: String!): ServiceJourney
    "Get all service journeys"
    serviceJourneys(
        "Set of ids of active dates to fetch serviceJourneys for."
        activeDates: [Date],
        "Set of ids of authorities to fetch serviceJourneys for."
        authorities: [String],
        "Set of ids of lines to fetch serviceJourneys for."
        lines: [String],
        "Set of ids of private codes to fetch serviceJourneys for."
        privateCodes: [String]
    ): [ServiceJourney]!
    "Get all active situations"
    situations(
        "Filter by reporting authorities."
        authorities: [String],
        "Filter by severity."
        severities: [Severity]
    ): [PtSituationElement]!
    "Get a single stopPlace based on its id)"
    stopPlace(id: String!): StopPlace
    "Get all stopPlaces"
    stopPlaces(ids: [String]): [StopPlace]!
    "Get all stop places within the specified bounding box"
    stopPlacesByBbox(
        authority: String,
        "If true only stop places with at least one visiting line are included."
        filterByInUse: Boolean = false,
        maximumLatitude: Float,
        maximumLongitude: Float,
        minimumLatitude: Float,
        minimumLongitude: Float,
        "MultiModalMode for query. To control whether multi modal parent stop places, their mono modal children or both are included in the response. Does not affect mono modal stop places that do not belong to a multi modal stop place."
        multiModalMode: MultiModalMode = parent
    ): [StopPlace]!
    "Input type for executing a travel search for a trip between two locations. Returns trip patterns describing suggested alternatives for the trip."
    trip(
        "Is bike rental allowed?"
        allowBikeRental: Boolean = false,
        "Whether the trip should depart at dateTime (false, the default), or arrive at dateTime."
        arriveBy: Boolean = false,
        "How many service journeys used in a tripPatterns should be banned from inclusion in successive tripPatterns. Counting from start of tripPattern."
        banFirstServiceJourneysFromReuseNo: Int = 2147483647,
        "Parameters for indicating authorities, lines or quays not be used in the trip patterns"
        banned: InputBanned,
        "The maximum bike speed along streets, in meters per second"
        bikeSpeed: Float = 5.0,
        "Whether legs should be compacted by performing a reversed search. Experimental argument, will be removed!."
        compactLegsByReversedSearch: Boolean = true,
        "Date and time for the earliest time the user is willing to start the journey (if arriveBy=false/not set) or the latest acceptable time of arriving (arriveBy=true). Defaults to now"
        dateTime: DateTime,
        "The start location"
        from: Location!,
        "Search algorithm tuning parameter."
        heuristicStepsPerMainStep: Int = 8,
        "DEPRECATED - For debugging only. Ignores interchanges defined in timetable data."
        ignoreInterchanges: Boolean = false,
        "Ignore the MinimumBookingPeriod defined on the ServiceJourney and allow itineraries to start immediately after the current time."
        ignoreMinimumBookingPeriod: Boolean = false,
        "When true, realtime updates are ignored during this search."
        ignoreRealtimeUpdates: Boolean = false,
        "When true, service journeys cancelled in scheduled route data will be included during this search."
        includePlannedCancellations: Boolean = false,
        locale: Locale = no,
        "Maximum time for the ride part of \"kiss and ride\" and \"ride and kiss\"."
        maxPreTransitTime: Int = 600,
        "Max walk distance for access/egress legs."
        maxPreTransitWalkDistance: Float = 1.7976931348623157E+308,
        "The maximum walk distance allowed for transfers."
        maxTransferWalkDistance: Float = 2000.0,
        "Maximum number of transfers"
        maximumTransfers: Int = 10,
        "DEPRECATED - Use maxPreTransitWalkDistance/maxTransferWalkDistance instead. The maximum distance (in meters) the user is willing to walk. Note that trip patterns with longer walking distances will be penalized, but not altogether disallowed. Maximum allowed value is 15000 m"
        maximumWalkDistance: Float = 5000.0,
        "A global minimum transfer time (in seconds) that specifies the minimum amount of time that must pass between exiting one public transport vehicle and boarding another. This time is in addition to time it might take to walk between stops."
        minimumTransferTime: Int = 120,
        "The set of modes that a user is willing to use. Defaults to [air, bus, cableway, water, funicular, lift, rail, metro, tram, coach, transit, foot]"
        modes: [Mode] = [foot, tram, metro, rail, bus, water, cableway, lift, funicular, transit, air, coach],
        "The maximum number of trip patterns to return."
        numTripPatterns: Int = 3,
        "The set of characteristics that the user wants to optimise for -- defaults to quick"
        optimisationMethod: OptimisationMethod = quick,
        "A multiplier in cost when over the maximum time of the ride part of \"kiss and ride\" and \"ride and kiss\"."
        preTransitOverageRate: Float = 10.0,
        "A one time jump in cost for exceeding the maximum time of the ride part of \"kiss and ride\" and \"ride and kiss\"."
        preTransitPenalty: Float = 300.0,
        "How much worse driving before and after transit is than riding on transit. Applies to ride and kiss, kiss and ride and park and ride."
        preTransitReluctance: Float = 4.0,
        "Parameters for indicating authorities or lines that preferably should be used in trip patters. A cost is applied to boarding nonpreferred authorities or lines (otherThanPreferredRoutesPenalty)."
        preferred: InputPreferred,
        "For debugging only."
        reverseOptimizeOnTheFly: Boolean = false,
        "The end location"
        to: Location!,
        "An extra penalty added on transfers (i.e. all boardings except the first one). The transferPenalty is used when a user requests even less transfers. In the latter case, we don't actually optimise for fewest transfers, as this can lead to absurd results. Consider a trip in New York from Grand Army Plaza (the one in Brooklyn) to Kalustyan's at noon. The true lowest transfers trip pattern is to wait until midnight, when the 4 train runs local the whole way. The actual fastest trip pattern is the 2/3 to the 4/5 at Nevins to the 6 at Union Square, which takes half an hour. Even someone optimise for fewest transfers doesn't want to wait until midnight. Maybe they would be willing to walk to 7th Ave and take the Q to Union Square, then transfer to the 6. If this takes less than transferPenalty seconds, then that's what we'll return."
        transferPenalty: Int = 0,
        """

        The extra cost per meter that is travelled by transit. This is a cost point peter meter, so it should in most
        cases be a very small fraction. The purpose of assigning a cost to distance is often because it correlates with
        fare prices and you want to avoid situations where you take detours or travel back again even if it is
        technically faster. Setting this value to 0 turns off the feature altogether.
        """
        transitDistanceReluctance: Float = 0.0,
        "Optional set of allowed submodes per transport mode provided in 'modes'. If at least one submode is set for a transport mode all submodes not set will be disregarded. Note that transportMode must also be included in 'modes' for the submodes to be allowed"
        transportSubmodes: [TransportSubmodeFilter] = [],
        "Parameters for indicating authorities or lines that preferably should not be used in trip patters. A cost is applied to boarding nonpreferred authorities or lines (otherThanPreferredRoutesPenalty)."
        unpreferred: InputUnpreferred,
        "Consider bike rental availability information when routing."
        useBikeRentalAvailabilityInformation: Boolean = false,
        useFlex: Boolean = false,
        "An ordered list of intermediate locations to be visited."
        vias: [Location],
        "DEPRECATED - ONLY FOR TESTING. Wait cost is multiplied by this value."
        waitReluctance: Float = 0.8,
        "DEPRECATED - ONLY FOR TESTING. Cost applied each time transit is boarded."
        walkBoardCost: Int = 600,
        "Walk cost is multiplied by this value. This is the main parameter to use for limiting walking."
        walkReluctance: Float = 4.0,
        "The maximum walk speed along streets, in meters per second"
        walkSpeed: Float = 1.3,
        "Whether the trip must be wheelchair accessible."
        wheelchair: Boolean = false,
        "Parameters for indicating the only authorities, lines or quays to be used in the trip patterns"
        whiteListed: InputWhiteListed
    ): Trip
}

"The default parameters used in travel searches."
type RoutingParameters {
    "Invariant: boardSlack + alightSlack <= transferSlack."
    alightSlack: Int
    allowBikeRental: Boolean
    "Separate cost for boarding a vehicle with a bicycle, which is more difficult than on foot."
    bikeBoardCost: Int
    bikeParkAndRide: Boolean
    "Cost to park a bike."
    bikeParkCost: Int
    "Time to park a bike."
    bikeParkTime: Int
    "Cost to drop-off a rented bike."
    bikeRentalDropOffCost: Int
    "Time to drop-off a rented bike."
    bikeRentalDropOffTime: Int
    "Cost to rent a bike."
    bikeRentalPickupCost: Int
    "Time to rent a bike."
    bikeRentalPickupTime: Int
    "Max bike speed along streets, in meters per second"
    bikeSpeed: Float
    "Invariant: boardSlack + alightSlack <= transferSlack."
    boardSlack: Int
    "The acceleration speed of an automobile, in meters per second per second."
    carAccelerationSpeed: Float
    "The deceleration speed of an automobile, in meters per second per second."
    carDecelerationSpeed: Float
    "Time to park a car in a park and ride, w/o taking into account driving and walking cost."
    carDropOffTime: Int
    "Max car speed along streets, in meters per second"
    carSpeed: Float
    "When true, do a full reversed search to compact the legs of the GraphPath."
    compactLegsByReversedSearch: Boolean
    "Option to disable the default filtering of GTFS-RT alerts by time."
    disableAlertFiltering: Boolean
    "If true, the remaining weight heuristic is disabled."
    disableRemainingWeightHeuristic: Boolean
    "What is the cost of boarding a elevator?"
    elevatorBoardCost: Int
    "How long does it take to get on an elevator, on average."
    elevatorBoardTime: Int
    "What is the cost of travelling one floor on an elevator?"
    elevatorHopCost: Int
    "How long does it take to advance one floor on an elevator?"
    elevatorHopTime: Int
    "Whether to apply the ellipsoid->geoid offset to all elevations in the response."
    geoIdElevation: Boolean
    "When true, realtime updates are ignored during this search."
    ignoreRealTimeUpdates: Boolean
    "When true, service journeys cancelled in scheduled route data will be included during this search."
    includedPlannedCancellations: Boolean
    "Whether to apply the ellipsoid->geoid offset to all elevations in the response."
    interchangeAllowedPenalty: Int
    kissAndRide: Boolean
    "The maximum time (in seconds) of pre-transit travel when using drive-to-transit (park and ride or kiss and ride)."
    maxPreTransitTime: Float
    "The maximum slope of streets for wheelchair trips."
    maxSlope: Float
    "The maximum distance (in meters) the user is willing to walk for transfer legs."
    maxTransferWalkDistance: Float
    "Maximum number of transfers returned in a trip plan."
    maxTransfers: Int
    "The maximum distance (in meters) the user is willing to walk for access/egress legs."
    maxWalkDistance: Float
    "Whether to apply the ellipsoid->geoid offset to all elevations in the response."
    noInterchangePenalty: Int
    "The maximum number of itineraries to return."
    numItineraries: Int
    "Accept only paths that use transit (no street-only paths)."
    onlyTransitTrips: Boolean
    "Penalty added for using every route that is not preferred if user set any route as preferred. We return number of seconds that we are willing to wait for preferred route."
    otherThanPreferredRoutesPenalty: Int
    parkAndRide: Boolean
    "A jump in cost for every second over the pre-transit time limit."
    preTransitOverageRate: Float
    "A jump in cost when stepping over the pre-transit time limit."
    preTransitPenalty: Float
    "How much worse driving before and after transit is than riding on transit. Applies to ride and kiss, kiss and ride and park and ride."
    preTransitReluctance: Float
    "Whether to apply the ellipsoid->geoid offset to all elevations in the response."
    preferredInterchangePenalty: Int
    "Whether to apply the ellipsoid->geoid offset to all elevations in the response."
    recommendedInterchangePenalty: Int
    "When true, reverse optimize this search on the fly whenever needed, rather than reverse-optimizing the entire path when it's done."
    reverseOptimizeOnTheFly: Boolean
    rideAndKiss: Boolean
    "Whether the planner should return intermediate stops lists for transit legs."
    showIntermediateStops: Boolean
    softPreTransitLimiting: Boolean
    softWalkLimiting: Boolean
    "A jump in cost for every meter over the walking limit."
    softWalkOverageRate: Float
    "A jump in cost when stepping over the walking limit."
    softWalkPenalty: Float
    "Used instead of walkReluctance for stairs."
    stairsReluctance: Float
    "An extra penalty added on transfers (i.e. all boardings except the first one)."
    transferPenalty: Int
    "A global minimum transfer time (in seconds) that specifies the minimum amount of time that must pass between exiting one transit vehicle and boarding another."
    transferSlack: Int
    "Multiplicative factor on expected turning time."
    turnReluctance: Float
    "Should traffic congestion be considered when driving?"
    useTraffic: Boolean
    "How much less bad is waiting at the beginning of the trip (replaces waitReluctance on the first boarding)."
    waitAtBeginningFactor: Float
    "How much worse is waiting for a transit vehicle than being on a transit vehicle, as a multiplier."
    waitReluctance: Float
    "This prevents unnecessary transfers by adding a cost for boarding a vehicle."
    walkBoardCost: Int
    "How much more reluctant is the user to walk on streets with car traffic allowed."
    walkOnStreetReluctance: Float
    "A multiplier for how bad walking is, compared to being in transit for equal lengths of time."
    walkReluctance: Float
    "Max walk speed along streets, in meters per second"
    walkSpeed: Float
    "Whether the trip must be wheelchair accessible."
    wheelChairAccessible: Boolean
}

"A planned vehicle journey with passengers."
type ServiceJourney {
    "Return a list of operating/service days a ServiceJourney run on. Cancellation/replaced alterations is not included."
    activeDates: [Date]!
    "Whether bikes are allowed on service journey."
    bikesAllowed: BikesAllowed
    "Booking arrangements for flexible services."
    bookingArrangements: BookingArrangement
    directionType: DirectionType
    "Returns scheduled passingTimes for this ServiceJourney for a given date, updated with realtime-updates (if available). NB! This takes a date as argument (default=today) and returns estimatedCalls for that date and should only be used if the date is known when creating the request. For fetching estimatedCalls for a given trip.leg, use leg.serviceJourneyEstimatedCalls instead."
    estimatedCalls(
        "Date to get estimated calls for. Defaults to today."
        date: Date
    ): [EstimatedCall]
    "Type of flexible service, or null if service is not flexible."
    flexibleServiceType: FlexibleServiceType
    id: ID!
    journeyPattern: JourneyPattern
    "List of keyValue pairs for the service journey."
    keyValues: [KeyValue]
    line: Line!
    "Publicly announced code for line, differentiating it from other lines for the same operator."
    linePublicCode: String @deprecated(reason: "Use line.publicCode instead.")
    notices: [Notice]!
    operator: Operator
    "Returns scheduled passing times only - without realtime-updates, for realtime-data use 'estimatedCalls'"
    passingTimes: [TimetabledPassingTime]!
    "Detailed path travelled by service journey."
    pointsOnLink: PointsOnLink
    "For internal use by operators."
    privateCode: String
    "Publicly announced code for service journey, differentiating it from other service journeys for the same line."
    publicCode: String
    "Quays visited by service journey"
    quays: [Quay!]!
    "When a trip is added using realtime-data, this is a reference to the replaced ServiceJourney."
    replacementForServiceJourneyId: String
    "For a Whether journey is as planned, a cancellation, an extra journey or replaced."
    serviceAlteration: ServiceAlteration @deprecated(reason: "The service-alteration might be different for each service day, so this method is not always giving the correct result. This method will return 'null' if there is a mix of different alterations.")
    "Get all situations active for the service journey"
    situations: [PtSituationElement]!
    transportMode: TransportMode
    "The transport submode of the journey, if different from lines transport submode."
    transportSubmode: TransportSubmode
    "Whether service journey is accessible with wheelchair."
    wheelchairAccessible: WheelchairBoarding
}

"Named place where public transport may be accessed. May be a building complex (e.g. a station) or an on-street location."
type StopPlace implements PlaceInterface {
    "This stop place's adjacent sites"
    adjacentSites: [String]
    description: String
    "List of visits to this stop place as part of vehicle journeys."
    estimatedCalls(
        includeCancelledTrips: Boolean = false,
        "Limit the total number of departures returned."
        numberOfDepartures: Int = 5,
        "Limit the number of departures per line and destination display returned. The parameter is only applied when the value is between 1 and 'numberOfDepartures'."
        numberOfDeparturesPerLineAndDestinationDisplay: Int,
        omitNonBoarding: Boolean = false,
        "DateTime for when to fetch estimated calls from. Default value is current time"
        startTime: DateTime,
        timeRange: Int = 86400,
        "Parameters for indicating the only authorities and/or lines or quays to list estimatedCalls for"
        whiteListed: InputWhiteListed,
        "Only show estimated calls for selected modes."
        whiteListedModes: [Mode]
    ): [EstimatedCall]!
    id: ID!
    latitude: Float
    longitude: Float
    name: String!
    "Returns parent stop for this stop"
    parent: StopPlace
    "Returns all quays that are children of this stop place"
    quays(
        "If true only quays with at least one visiting line are included."
        filterByInUse: Boolean = false
    ): [Quay]
    tariffZones: [TariffZone]!
    timezone: String!
    "The transport mode serviced by this stop place."
    transportMode: TransportMode
    "The transport submode serviced by this stop place."
    transportSubmode: TransportSubmode
    "Relative weighting of this stop with regards to interchanges."
    weighting: InterchangeWeighting
    "Whether this stop place is suitable for wheelchair boarding."
    wheelchairBoarding: WheelchairBoarding
}

type TariffZone {
    id: String
    name: String
}

type TimeAndDayOffset {
    "Number of days offset from base line time"
    dayOffset: Int
    "Local time"
    time: Time
}

"Scheduled passing times. These are not affected by real time updates."
type TimetabledPassingTime {
    "Scheduled time of arrival at quay"
    arrival: TimeAndDayOffset
    "Booking arrangements for flexible service."
    bookingArrangements: BookingArrangement
    "Scheduled time of departure from quay"
    departure: TimeAndDayOffset
    destinationDisplay: DestinationDisplay
    "Whether vehicle may be alighted at quay."
    forAlighting: Boolean
    "Whether vehicle may be boarded at quay."
    forBoarding: Boolean
    notices: [Notice]!
    quay: Quay
    "Whether vehicle will only stop on request."
    requestStop: Boolean
    serviceJourney: ServiceJourney
    "Whether this is a timing point or not. Boarding and alighting is not allowed at timing points."
    timingPoint: Boolean
}

"Description of a travel between two places."
type Trip {
    "The time and date of travel"
    dateTime: DateTime
    "Information about the timings for the trip generation"
    debugOutput: debugOutput!
    "The origin"
    fromPlace: Place!
    "A list of possible error messages as enum"
    messageEnums: [String]!
    "A list of possible error messages in cleartext"
    messageStrings: [String]!
    "The destination"
    toPlace: Place!
    "A list of possible trip patterns"
    tripPatterns: [TripPattern]!
}

"List of legs constituting a suggested sequence of rides and links for a specific trip."
type TripPattern {
    "The aimed date and time the trip ends."
    aimedEndTime: DateTime
    "The aimed date and time the trip starts."
    aimedStartTime: DateTime
    "This sums the direct durations of each leg. Be careful about using this, as it is not equal to the duration between startTime and endTime. See the directDuration documentation on Leg."
    directDuration: Long
    "Total distance for the trip, in meters."
    distance: Float
    "Duration of the trip, in seconds."
    duration: Long
    "Time that the trip arrives."
    endTime: DateTime @deprecated(reason: "Replaced with expectedEndTime")
    "The expected, realtime adjusted date and time the trip ends."
    expectedEndTime: DateTime
    "The expected, realtime adjusted date and time the trip starts."
    expectedStartTime: DateTime
    "A list of legs. Each leg is either a walking (cycling, car) portion of the trip, or a ride leg on a particular vehicle. So a trip where the use walks to the Q train, transfers to the 6, then walks to their destination, has four legs."
    legs: [Leg]!
    "Time that the trip departs."
    startTime: DateTime @deprecated(reason: "Replaced with expectedStartTime")
    "How much time is spent waiting for transit to arrive, in seconds."
    waitingTime: Long
    "How far the user has to walk, in meters."
    walkDistance: Float
    "How much time is spent walking, in seconds."
    walkTime: Long
    "Weight of the itinerary. Used for debugging. The result might have been modified after (e.g. by removing short legs) and will notnecessarily exactly represent the tripPattern. It is however the weightthat was the basis for choosing the result in the first place. If the result has been heavily modified, this field will be null."
    weight: Float
}

type ValidityPeriod {
    "End of validity period"
    endTime: DateTime
    "Start of validity period"
    startTime: DateTime
}

type debugOutput {
    totalTime: Long
}

type infoLink {
    "Label"
    label: String
    "URI"
    uri: String
}

"A connection to a list of items."
type placeAtDistanceConnection {
    "a list of edges"
    edges: [placeAtDistanceEdge]
    "details about this specific page"
    pageInfo: PageInfo!
}

"An edge in a connection"
type placeAtDistanceEdge {
    "cursor marks a unique position or index into the connection"
    cursor: String!
    "The item at the end of the edge"
    node: PlaceAtDistance
}

"A connection to a list of items."
type quayAtDistanceConnection {
    "a list of edges"
    edges: [quayAtDistanceEdge]
    "details about this specific page"
    pageInfo: PageInfo!
}

"An edge in a connection"
type quayAtDistanceEdge {
    "cursor marks a unique position or index into the connection"
    cursor: String!
    "The item at the end of the edge"
    node: QuayAtDistance
}

enum AbsoluteDirection {
    east
    north
    northeast
    northwest
    south
    southeast
    southwest
    west
}

enum BikesAllowed {
    "The vehicle being used on this particular trip can accommodate at least one bicycle."
    allowed
    "There is no bike information for the trip."
    noInformation
    "No bicycles are allowed on this trip."
    notAllowed
}

enum BookingAccess {
    authorisedPublic
    other
    publicAccess
    staff
}

enum BookingMethod {
    callDriver
    callOffice
    none
    online
    other
    phoneAtStop
    text
}

enum DirectionType {
    anticlockwise
    clockwise
    inbound
    outbound
    unknown
}

enum FilterPlaceType {
    "Bicycle rent stations"
    bicycleRent
    "Bike parks"
    bikePark
    "Car parks"
    carPark
    "Quay"
    quay
    "StopPlace"
    stopPlace
}

enum FlexibleLineType {
    corridorService
    fixed
    fixedStopAreaWide
    flexibleAreasOnly
    freeAreaAreaWide
    hailAndRideSections
    mainRouteWithFlexibleEnds
    mixedFlexible
    mixedFlexibleAndFixed
    other
}

enum FlexibleServiceType {
    dynamicPassingTimes
    fixedHeadwayFrequency
    fixedPassingTimes
    notFlexible
    other
}

enum InterchangeWeighting {
    "Third highest priority interchange."
    interchangeAllowed
    "Interchange not allowed."
    noInterchange
    "Highest priority interchange."
    preferredInterchange
    "Second highest priority interchange."
    recommendedInterchange
}

enum Locale {
    no
    us
}

enum Mode {
    air
    bicycle
    bus
    cableway
    car
    "Combine with foot and transit for kiss and ride."
    car_dropoff
    "Combine with foot and transit for park and ride."
    car_park
    "Combine with foot and transit for ride and kiss."
    car_pickup
    coach
    foot
    funicular
    lift
    metro
    rail
    tram
    "Any for of public transportation"
    transit
    water
}

enum MultiModalMode {
    "Both multiModal parents and their mono modal child stop places."
    all
    "Only mono modal children stop places, not their multi modal parent stop"
    child
    "Multi modal parent stop places without their mono modal children."
    parent
}

enum Occupancy {
    "The vehicle can currently accommodate only standing passengers and has limited space for them."
    crushedStandingRoomOnly
    "The vehicle is considered empty by most measures, and has few or no passengers onboard, but is still accepting passengers."
    empty
    "The vehicle has a small percentage of seats available. What percentage of free seats out of the total seats available is to be considered small enough to fall into this category is determined at the discretion of the producer."
    fewSeatsAvailable
    "The vehicle is considered full by most measures, but may still be allowing passengers to board."
    full
    "The vehicle has a large percentage of seats available. What percentage of free seats out of the total seats available is to be considered large enough to fall into this category is determined at the discretion of the producer."
    manySeatsAvailable
    "The vehicle can not accept passengers."
    notAcceptingPassengers
    "The vehicle can currently accommodate only standing passengers."
    standingRoomOnly
    "The Occupancy is unknown. DEFAULT."
    unknown
}

enum OptimisationMethod {
    flat
    greenways
    quick
    safe
    transfers
    triangle
}

enum PurchaseMoment {
    afterBoarding
    beforeBoarding
    beforeBoardingOnly
    inAdvance
    inAdvanceOnly
    onBoarding
    onBoardingOnly
    onCheckIn
    onCheckOut
    onReservation
    other
    subscriptionOnly
}

enum PurchaseWhen {
    advanceAndDayOfTravel
    advanceOnly
    dayOfTravelOnly
    other
    subscriptionChargeMoment
    timeOfTravelOnly
    untilPreviousDay
}

enum RealtimeState {
    "The service journey has been added using a real-time update, i.e. the service journey was not present in the regular time table."
    Added
    "The service journey has been canceled by a real-time update."
    canceled
    "The service journey information has been updated and resulted in a different journey pattern compared to the journey pattern of the scheduled service journey."
    modified
    "The service journey information comes from the regular time table, i.e. no real-time update has been applied."
    scheduled
    "The service journey information has been updated, but the journey pattern stayed the same as the journey pattern of the scheduled service journey."
    updated
}

enum RelativeDirection {
    circleClockwise
    circleCounterclockwise
    continue
    depart
    elevator
    hardLeft
    hardRight
    left
    right
    slightlyLeft
    slightlyRight
    uturnLeft
    uturnRight
}

enum ReportType {
    "Indicates a general info-message that should not affect trip."
    general
    "Indicates an incident that may affect trip."
    incident
}

enum ServiceAlteration {
    cancellation
    extraJourney
    planned
    replaced
}

enum Severity {
    "Situation has no impact on trips."
    noImpact
    "Situation has an impact on trips (default)."
    normal
    "Situation has a severe impact on trips."
    severe
    "Situation has a slight impact on trips."
    slight
    "Severity is undefined."
    undefined
    "Situation has unknown impact on trips."
    unknown
    "Situation has a very severe impact on trips."
    verySevere
    "Situation has a very slight impact on trips."
    verySlight
}

enum StopCondition {
    "Situation applies when stop is the destination of the leg."
    destination
    "Situation applies when transfering to another leg at the stop."
    exceptionalStop
    "Situation applies when passing the stop, without stopping."
    notStopping
    "Situation applies when at the stop, and the stop requires a request to stop."
    requestStop
    "Situation applies when stop is the startpoint of the leg."
    startPoint
}

enum StopType {
    flexible_area
    regular
}

enum TransportMode {
    air
    bus
    cableway
    coach
    funicular
    lift
    metro
    rail
    tram
    unknown
    water
}

enum TransportSubmode {
    SchengenAreaFlight
    airportBoatLink
    airportLinkBus
    airportLinkRail
    airshipService
    allFunicularServices
    allHireVehicles
    allTaxiServices
    bikeTaxi
    blackCab
    cableCar
    cableFerry
    canalBarge
    carTransportRailService
    chairLift
    charterTaxi
    cityTram
    communalTaxi
    commuterCoach
    crossCountryRail
    dedicatedLaneBus
    demandAndResponseBus
    domesticCharterFlight
    domesticFlight
    domesticScheduledFlight
    dragLift
    expressBus
    funicular
    helicopterService
    highFrequencyBus
    highSpeedPassengerService
    highSpeedRail
    highSpeedVehicleService
    hireCar
    hireCycle
    hireMotorbike
    hireVan
    intercontinentalCharterFlight
    intercontinentalFlight
    international
    internationalCarFerry
    internationalCharterFlight
    internationalCoach
    internationalFlight
    internationalPassengerFerry
    interregionalRail
    lift
    local
    localBus
    localCarFerry
    localPassengerFerry
    localTram
    longDistance
    metro
    miniCab
    mobilityBus
    mobilityBusForRegisteredDisabled
    nationalCarFerry
    nationalCoach
    nationalPassengerFerry
    nightBus
    nightRail
    postBoat
    postBus
    rackAndPinionRailway
    railReplacementBus
    railShuttle
    railTaxi
    regionalBus
    regionalCarFerry
    regionalCoach
    regionalPassengerFerry
    regionalRail
    regionalTram
    replacementRailService
    riverBus
    roadFerryLink
    roundTripCharterFlight
    scheduledFerry
    schoolAndPublicServiceBus
    schoolBoat
    schoolBus
    schoolCoach
    shortHaulInternationalFlight
    shuttleBus
    shuttleCoach
    shuttleFerryService
    shuttleFlight
    shuttleTram
    sightseeingBus
    sightseeingCoach
    sightseeingFlight
    sightseeingService
    sightseeingTram
    sleeperRailService
    specialCoach
    specialNeedsBus
    specialTrain
    streetCableCar
    suburbanRailway
    telecabin
    telecabinLink
    touristCoach
    touristRailway
    trainFerry
    trainTram
    tube
    undefined
    undefinedFunicular
    unknown
    urbanRailway
    waterTaxi
}

enum VertexType {
    bikePark
    bikeShare
    normal
    parkAndRide
    transit
}

enum WheelchairBoarding {
    "There is no accessibility information for the stopPlace/quay."
    noInformation
    "Wheelchair boarding/alighting is not possible at this stop."
    notPossible
    "Boarding wheelchair-accessible serviceJourneys is possible at this stopPlace/quay."
    possible
}

scalar Coordinates

"Date  using the format: yyyy-MM-dd. Example: 2017-04-23"
scalar Date

"DateTime format accepting ISO dates. Return values on format: yyyy-MM-dd'T'HH:mm:ssXXXX. Example: 2017-04-23T18:25:43+0100"
scalar DateTime

"Time using the format: HH:mm:SS. Example: 18:25:SS"
scalar LocalTime

"Long type"
scalar Long

"Time using the format: HH:mm:ss. Example: 18:25:43"
scalar Time

"Filter trips by disallowing trip patterns involving certain elements"
input InputBanned {
    "Set of ids for authorities that should not be used"
    authorities: [String] = []
    "Set of ids for lines that should not be used"
    lines: [String] = []
    "Deprecated! Use 'authorities' instead."
    organisations: [String] = []
    "Set of ids of quays that should not be allowed for boarding or alighting. Trip patterns that travel through the quay will still be permitted."
    quays: [String] = []
    "Set of ids of quays that should not be allowed for boarding, alighting or traveling thorugh."
    quaysHard: [String] = []
    "Set of ids of service journeys that should not be used."
    serviceJourneys: [String] = []
}

"Input type for coordinates in the WGS84 system"
input InputCoordinates {
    "The latitude of the place."
    latitude: Float!
    "The longitude of the place."
    longitude: Float!
}

input InputFilters {
    "Bike parks to include by id."
    bikeParks: [String]
    "Bike rentals to include by id."
    bikeRentalStations: [String]
    "Car parks to include by id."
    carParks: [String]
    "Lines to include by id."
    lines: [String]
    "Quays to include by id."
    quays: [String]
}

"Preferences for trip search."
input InputPreferred {
    "Set of ids of authorities preferred by user."
    authorities: [String] = []
    "Set of ids of lines preferred by user."
    lines: [String] = []
    "Deprecated! Use 'authorities' instead."
    organisations: [String] = []
    "Penalty added for using a line that is not preferred if user has set any line as preferred. In number of seconds that user is willing to wait for preferred line."
    otherThanPreferredLinesPenalty: Int = 300
}

"Negative preferences for trip search. Unpreferred elements may still be used in suggested trips if alternatives are not desirable, see InputBanned for hard limitations."
input InputUnpreferred {
    "Set of ids of authorities user prefers not to use."
    authorities: [String] = []
    "Set of ids of lines user prefers not to use."
    lines: [String] = []
    "Deprecated! Use 'authorities' instead."
    organisations: [String] = []
}

"Filter trips by only allowing trip patterns involving certain elements. If both lines and authorities are specificed, only one must be valid for each trip to be used."
input InputWhiteListed {
    "Set of ids for authorities that should be used"
    authorities: [String]
    "Set of ids for lines that should be used"
    lines: [String]
    "Deprecated! Use 'authorities' instead."
    organisations: [String]
}

"Input format for specifying a location through either a place reference (id), coordinates or both. If both place and coordinates are provided the place ref will be used if found, coordinates will only be used if place is not known."
input Location {
    "Coordinates for the location"
    coordinates: InputCoordinates
    "The name of the location."
    name: String
    "Id for the place."
    place: String
}

"Filter trips by allowing only certain transport submodes per mode."
input TransportSubmodeFilter {
    "Set of ids for lines that should be used"
    transportMode: TransportMode!
    "Set of transport submodes allowed for transport mode."
    transportSubmodes: [TransportSubmode]!
}
